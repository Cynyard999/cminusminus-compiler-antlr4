可以随意分配32个寄存器

栈的管理可以不用遵循约定，可以使用除了栈之外的方式来进行过程调用间的数据传递

但是建议你去遵守这种约定

**注意事项**

指令选择：一条中间代码可以翻译成多条目标代码，可能多条中间代码对应一条目标代码

寄存器分配：处理器所拥有的寄存器数量是有限的

栈管理：需要借助寄存器或者栈来处理函数调用以及参数传递的问题

代码段.text开头，数据段.data开头，注释以#开头

数据段中可以为汇编代码中需要用到的常量和全局变量申请空间 `name: storage_type value`
例如

```
value1: .word 3 # 申请一个初始值为3的整数
array1: .byte 'a', 'b' # 创建一个数组，拥有两个byte，初始值是字符a和字符b
arrty2: .half 0x01, 0x02 # 半字数组
array3: .space 40 # 创建连续的40字节的空间，能够被用来存储10个integer或者40个char
string1: .ascii "hello world" # 声明一个字符串，并且不以null结尾
string2: .asciiz "hello world" # 声明一个字符串，并且以null结尾

```


寄存器作用

$0 $zero 常数0
$1 $at 汇编器保留
$2-$3 $v0-$v1 表达式求值或者函数的结果
$4-$7 $a0-$a3 函数的首四个参数(跨函数不保留)
$8-$15 $t0-$t7 函数调用者负责保存(跨函数不保留)
$16-$23 $s0-$s7 函数负责保存和恢复(跨函数不保留)
$24-$25 $t8-$t9 函数调用者负责保存(跨函数不保留)
$26-$27 $k0-$k1 中断处理保留
$28 $gp 指向静态数据段64K内存空间的中部
$29 $sp 栈顶指针
$30 $s8或$fp MIPS32作为$s8， GCC作为帧指针
$31 $ra 返回地址


系统调用
$v0中存储一个系统调用的代码，如果有必要向其他寄存器中存入相关的参数，最后再使用syscall


