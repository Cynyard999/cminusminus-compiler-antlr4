可以随意分配32个寄存器

栈的管理可以不用遵循约定，可以使用除了栈之外的方式来进行过程调用间的数据传递

但是建议你去遵守这种约定

**注意事项**

指令选择：一条中间代码可以翻译成多条目标代码，可能多条中间代码对应一条目标代码

寄存器分配：处理器所拥有的寄存器数量是有限的

栈管理：需要借助寄存器或者栈来处理函数调用以及参数传递的问题

代码段.text开头，数据段.data开头，注释以#开头

数据段中可以为汇编代码中需要用到的常量和全局变量申请空间 `name: storage_type value`
例如

```
value1: .word 3 # 申请一个初始值为3的整数
array1: .byte 'a', 'b' # 创建一个数组，拥有两个byte，初始值是字符a和字符b
arrty2: .half 0x01, 0x02 # 半字数组
array3: .space 40 # 创建连续的40字节的空间，能够被用来存储10个integer或者40个char
string1: .ascii "hello world" # 声明一个字符串，并且不以null结尾
string2: .asciiz "hello world" # 声明一个字符串，并且以null结尾

```



**常用伪指令**

![image-20220217104720781](/Users/cynyard/Library/Application Support/typora-user-images/image-20220217104720781.png)



**寄存器作用**

![image-20220217104347208](/Users/cynyard/Library/Application Support/typora-user-images/image-20220217104347208.png)

\$zero 硬件上永远是0

\$at, \$k0, \$k1 专门预留给汇编器使用

\$v0, \$v1 专门用来存放函数的返回值，在函数内部也可以使用。不过在当前函数返回或者调用其他函数的时候应该妥善处理

\$a0-\$a3 专门存放函数参数，在函数内部可以视作与\$t0-\$t9相同

\$t0-\$t9这10个寄存器可以任意使用，但是由于是属于调用者保存的寄存器，调用子函数之前如果其中有任何有用的数据都要先保存到内存中，以免被子函数覆盖

\$s0-\$s7也可以任意使用，不过他们是被调用者保存的寄存器，也就是说如果一个函数中要修改这些寄存器中的值，需要在函数开头先将其中原有的数据压栈，然后在函数末尾恢复这些数据

\$gp固定指向64K静态数据区的中央，\$sp固定指向栈的顶部

\$30可以作为\$s8也可以作为栈帧指针使用

\$ra专门用来保存函数的返回地址，与跳转有关的jal指令和jr指令都会对该寄存器进行操作

所以说，可以随意使用的有\$t0-\$t9和\$s0-\$s7（\$s8）





**系统调用**
$v0中存储一个系统调用的代码，如果有必要向其他寄存器中存入相关的参数，最后再使用syscall

![image-20220217104500218](/Users/cynyard/Library/Application Support/typora-user-images/image-20220217104500218.png)

```
li $v0, 4 # print_string系统调用
la $a0, _prompt # 第一个参数，将需要打印的字符串地址加载到a0中
syscall
```



**处理中间代码**

模式匹配的问题，特定的模式对应到目标代码上，取决于中间代码本身蕴含信息的多少以及目标机器采用的是RISC(Reduced Instruction Set Computing)还是CISC(Complex Instruction Set Computing)类型的指令集

我们使用的MIPS32指令集是属于处理起来比较简单的RISC指令集



线性IR最简单的指令选择方式就是逐条将中间代码对应到目标代码上

<img src="/Users/cynyard/Library/Application Support/typora-user-images/image-20220217110246290.png" alt="image-20220217110246290" style="zoom:50%;" />



但这种方式并不唯一，并不能得到高效的目标代码，例如访问int数组元素a[3]，变量a的首地址已经被保存在了\$t1中，按照表格翻译的语句为

```
addi $t2, $t1, 12
lw $t3, 0($t2)
```

其实可以精简为

```
lw $t3, 12($t2)
```

所以有时候为了得到更高效的目标代码，我们需要一次考察多条中间代码，这样可以将多条中间代码翻译为一条MIPS32代码，可以看作是一个多行的模式匹配，也可以看成用一个滑动窗口或者Peephole滑过中间代码并且查找可能的翻译方案的过程





**寄存器分配**

除了load和store类型指令之外，其他指令的所有操作数都必须来自寄存器而不是内存，除了数组和结构体必须放到内存当中，中间代码里的任何一个非零变量或者临时变量只要参与了运算，他的值必定被载入到某个寄存器中。

在某个特定的程序点上选择哪个寄存器来保存变量的值，就是寄存器分配的问题



**朴素寄存器分配算法**

把所有用到的变量或者临时变量都放在内存里，这样我们每翻译一条中间代码之前我们都需要把用到的变量先加载到寄存器中，得到计算结果之后再将结果写回内存



**局部寄存器分配算法**

事先将整段代码拆分为一个个基本块，在每个基本块内部根据各种原则为变量分配寄存器，在基本块结束的时候需要将本块中所有修改过的变量都写回内存



