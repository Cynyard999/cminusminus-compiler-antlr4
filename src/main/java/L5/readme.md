可以随意分配32个寄存器

栈的管理可以不用遵循约定，可以使用除了栈之外的方式来进行过程调用间的数据传递

但是建议你去遵守这种约定

**注意事项**

指令选择：一条中间代码可以翻译成多条目标代码，可能多条中间代码对应一条目标代码

寄存器分配：处理器所拥有的寄存器数量是有限的

栈管理：需要借助寄存器或者栈来处理函数调用以及参数传递的问题

代码段.text开头，数据段.data开头，注释以#开头

数据段中可以为汇编代码中需要用到的常量和全局变量申请空间 `name: storage_type value`
例如

```
value1: .word 3 # 申请一个初始值为3的整数
array1: .byte 'a', 'b' # 创建一个数组，拥有两个byte，初始值是字符a和字符b
arrty2: .half 0x01, 0x02 # 半字数组
array3: .space 40 # 创建连续的40字节的空间，能够被用来存储10个integer或者40个char
string1: .ascii "hello world" # 声明一个字符串，并且不以null结尾
string2: .asciiz "hello world" # 声明一个字符串，并且以null结尾

```



**常用伪指令**

![image-20220217104720781](/Users/cynyard/Library/Application Support/typora-user-images/image-20220217104720781.png)



**寄存器作用**

![image-20220217104347208](/Users/cynyard/Library/Application Support/typora-user-images/image-20220217104347208.png)

\$zero 硬件上永远是0

\$at, \$k0, \$k1 专门预留给汇编器使用

\$v0, \$v1 专门用来存放函数的返回值，在函数内部也可以使用。不过在当前函数返回或者调用其他函数的时候应该妥善处理

\$a0-\$a3 专门存放函数参数，在函数内部可以视作与\$t0-\$t9相同

\$t0-\$t9这10个寄存器可以任意使用，但是由于是属于调用者保存的寄存器，调用子函数之前如果其中有任何有用的数据都要先保存到内存中，以免被子函数覆盖

\$s0-\$s7也可以任意使用，不过他们是被调用者保存的寄存器，也就是说如果一个函数中要修改这些寄存器中的值，需要在函数开头先将其中原有的数据压栈，然后在函数末尾恢复这些数据

\$gp固定指向64K静态数据区的中央，\$sp固定指向栈的顶部

\$30可以作为\$s8也可以作为栈帧指针使用

\$ra专门用来保存函数的返回地址，与跳转有关的jal指令和jr指令都会对该寄存器进行操作

所以说，可以随意使用的有\$t0-\$t9和\$s0-\$s7（\$s8）





**系统调用**
$v0中存储一个系统调用的代码，如果有必要向其他寄存器中存入相关的参数，最后再使用syscall

![image-20220217104500218](/Users/cynyard/Library/Application Support/typora-user-images/image-20220217104500218.png)

```
li $v0, 4 # print_string系统调用
la $a0, _prompt # 第一个参数，将需要打印的字符串地址加载到a0中
syscall
```



**处理中间代码**

模式匹配的问题，特定的模式对应到目标代码上，取决于中间代码本身蕴含信息的多少以及目标机器采用的是RISC(Reduced Instruction Set Computing)还是CISC(Complex Instruction Set Computing)类型的指令集

我们使用的MIPS32指令集是属于处理起来比较简单的RISC指令集



线性IR最简单的指令选择方式就是逐条将中间代码对应到目标代码上

<img src="/Users/cynyard/Library/Application Support/typora-user-images/image-20220217110246290.png" alt="image-20220217110246290" style="zoom:50%;" />



但这种方式并不唯一，并不能得到高效的目标代码，例如访问int数组元素a[3]，变量a的首地址已经被保存在了\$t1中，按照表格翻译的语句为

```
addi $t2, $t1, 12
lw $t3, 0($t2)
```

其实可以精简为

```
lw $t3, 12($t2)
```

所以有时候为了得到更高效的目标代码，我们需要一次考察多条中间代码，这样可以将多条中间代码翻译为一条MIPS32代码，可以看作是一个多行的模式匹配，也可以看成用一个滑动窗口或者Peephole滑过中间代码并且查找可能的翻译方案的过程





**寄存器分配**

除了load和store类型指令之外，其他指令的所有操作数都必须来自寄存器而不是内存，除了数组和结构体必须放到内存当中，中间代码里的任何一个非零变量或者临时变量只要参与了运算，他的值必定被载入到某个寄存器中。

在某个特定的程序点上选择哪个寄存器来保存变量的值，就是寄存器分配的问题



**朴素寄存器分配算法**

把所有用到的变量或者临时变量都放在内存里，这样我们每翻译一条中间代码之前我们都需要把用到的变量先加载到寄存器中，得到计算结果之后再将结果写回内存



**局部寄存器分配算法**

事先将整段代码拆分为一个个基本块，在每个基本块内部根据各种原则为变量分配寄存器，在基本块结束的时候需要将本块中所有修改过的变量都写回内存



**图染色算法**



**活跃变量分析算法**



**栈管理**

函数调用包括控制流转移和数据流转移两个部分

控制流转移：保存PC当前的值到\$ra中，然后跳转，可以直接使用jal指令实现

数据流转移：传递参数和返回值

函数调用使用jal指令，函数返回只用jr指令

如果参数少于4个，使用\$a0-\$a3这四个寄存器传递参数，如果多余四个，多出的部分以此压到栈里

返回的时候直接将返回值放到\$v0中即可



如果使用了jal调用了另一个函数，为了让另一个函数返回之后能够将原来\$ra中的内容恢复出来，调用者在进行函数调用之前需要负责把\$ra暂存起来，即在栈中



对于那些在寄存器分配过程中需要溢出到内存中的变量来说，如果是全局变量就需要溢出到静态数据区中，如果是局部变量，一般被溢出到栈中。

为了简便，你可以将所有需要被溢出的变量都安排到栈上

不管占用多大的空间，数组和结构体一定都是在内存中的，和溢出变量一样，这些内存空间实际上都在栈上



每个函数在栈上都会单独占用一块单独的内存空间，也就是活动记录或者stack frame

<img src="/Users/cynyard/Library/Application Support/typora-user-images/image-20220218153925741.png" alt="image-20220218153925741" style="zoom:50%;" />



sp指向栈顶，fp指向当前活动记录的底部

图片中，fp上面（更高地址）是传递给本函数的参数，fp下面（更低地址）是返回地址，被调用者保存的寄存器内容依据局部数组、变量或者临时变量



栈的管理中，有一个sp其实已经足够了，fp并不是必须的，但sp是经常变化的，使用sp来访问栈帧里保存的局部变量比较麻烦，因为偏移量会经常改变，fp一旦确定后就不再变化

如果决定使用fp的话，使得本函数返回之后能够恢复上层函数的fp，需要在栈帧中把旧有的fp也存起来





调用者保存还是被调用者保存？

MIPS32规定t0-t9是调用者保存，s0-s8是被调用者保存



所以调用者保存的寄存器的值在函数调用前后有可能会发生改变

被调用者保存的寄存器的值在函数调用前后一定不会发生改变



所以t0和t9应该尽量分配给那些短期使用的变量或者临时变量，s0和s9应当尽量分配给那些生存期比较长，尤其是跨越了函数调用的变量或者临时变量



如果栈顶向低地址增长：

调用者的过程调用序列，live就是保存着活跃变量的所有调用者保存寄存器

```
# 保存寄存器
sw live1, offset1($sp)
...
sw livek, offsetk($sp)
# 一次性修改了栈顶，也可以保存一个修改一个
subu $sp, $sp, max{0, 4 * (n-5)}
move $a0, arg1
...
move $a3, arg4
sw arg5, 0($sp)
...
sw argn, (4*(n-5))($sp)
jal g
# 把栈顶恢复到传入参数之前，不用把参数取出来
addi $sp, $sp, max{0, 4*(n-5)}
# 恢复寄存器
lw live1, offset1($sp)
...
lw livek, offsetk($sp)
```





被调用者的过程调用序列

```

################### Prologue ###################
# 开一个默认大小的栈帧
subu $sp, $sp, framesizeg
# 先存ra
sw $ra, (framesizeg-4)($sp)
# 再存fp
sw $fp, (framesizeg-8)($sp)
# 修改fp
addi $fp, $sp, framesizeg
# 存寄存器
sw reg1, offset1($sp)
...
sw regk, offsetk($sp)
# 取得传入的额外参数，这里也可以用fp
lw p5, framesizeg($sp)
...
lw pn, (framesizeg+4*(n-5))($sp)
...
...
################### Epilogue ###################
# 恢复寄存器
lw reg1, offset1($sp)
...
lw regk, offsetk($sp)
# 恢复ra和fp
lw $ra, (framesizeg-4)($sp)
lw $fp, (framesizeg-8)($sp)
# 恢复sp（其实感觉可以用fp的值来给sp恢复，然后sp就不用固定在那个位置
addi $sp, $sp, framesizeg
# 跳转回
jr $ra
```



寄存器s0-s8在函数调用前后由被调用者保存其内容不会发生变化，因此不需要对他们考虑

寄存器t0-t9在函数调用之后，其中的内容会全部丢失（可能，如果调用的函数用到了这些寄存器）



如果使用了局部寄存器分配算法，那么在处理到中间代码CALL的时候，如果t0-t9保存有任何变量的值，就需要在调用序列中将所有的这些变量全部溢出到内存中，调用结束后再重新读取回来



更简单的做法是将中间代码CALL单独作为一个基本块进行处理，这样，由于将所有变量溢出到内存这件事情上再上一个基本块结束时已经做过了，所以在CALL语句的时候不需要做任何事情





**提示**

确定指令选择机制以及寄存器分配算法



如果采用了局部寄存器分配算法，可能需要考虑如何实现寄存器描述符以及变量描述符

如果使用前面介绍的寄存器分配算法，只需要保存每个寄存器的空闲状态，每个变量下次被使用到的位置是哪里就可以



如果使用课本上介绍的局部寄存器分配算法，需要记录每个寄存器中保存的变量，以及每个变量的有效值位于那个寄存器中，我们介意使用位向量作为寄存器描述符以及变量描述符的数据结构



开始的时候可以无视与函数调用有关的ARG，PARAM，RETURN和CALL语句，专心处理其它类型的中间代码

先假设寄存器有无限多个，试着完成指令选择，然后将经过指令选择之后的代码打印出来













